using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class QuestRenderer : MonoBehaviour
{
    [System.Serializable]
    public class QuestDataProperty
    {
        public Sprite sprite;
        public string description;
    }

    public Button previousPageButton, nextPageButton;
    public Image questImg;
    public TextMeshProUGUI descriptionTxt;

    public List<QuestDataProperty> questData;

    int currentPage; //=0??? / ? ??? ?? ? ???? ???? ???

    // Start is called before the first frame update
    void Start()
    {
        UpdateUI();
    }


    //?? ???? ?? ??? ??? ???
    //??? ??? ???? ??? ??? ?? ????
    void UpdateUI()
    {   //?? ??? ?? ???? ?? ??
        //false? ???? interactable? ? ?
        previousPageButton.interactable = currentPage > 0;
        nextPageButton.interactable = currentPage < questData.Count - 1;
        //???? ??? ???? ??? ??


        UpdateContent();
    }
    //?? ???? ?? ??? ???
    void UpdateContent()
    {
        //questData ?? ???? ??? ?????? ???? ?
        questImg.sprite = questData[currentPage].sprite;

        StopAllCoroutines(); //?????? ??->?? ??? ?????...?->????
        StartCoroutine(AppearTextOneByOne(0.05f));//???? ~? /  ?? ?? ??
    }

    IEnumerator AppearTextOneByOne(float interval)
    {
        int index = 1;
        //?? ???? ? ?? -> questData? currentPage
        string description = questData[currentPage].description;

        while (index <= description.Length)
        {
            descriptionTxt.text = description.Substring(0, index); //0~index ???
            yield return new WaitForSeconds(interval); //interval?? ???? ?? / ?????
            index++;

        }
    }

    //??? ???? ?? ???? ??~
    public void OnClickPrevButton()
    {
        Debug.Log("click prev button");

        currentPage--;

        UpdateUI();
    }

    public void OnClickNextButton()
    {
        Debug.Log("click next button");

        currentPage++;

        UpdateUI();
    }
}
 